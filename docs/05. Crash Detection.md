# Overview

In this lab we will begin to act on the data.  We will also see how Jet and IMDG together form a powerful combination.   

The engine code 'B0001' indicates that the driver airbag has deployed and is a strong indicator that a crash has occurred.  We will make a new pipeline that listens for changes from the "vehicles" map (i.e. the same map that is loaded by the ingest pipeline).  The pipeline should then filter for pings with a 'B0001' engine code.  When a crashed vehicle is found, we will use an [aggregator](https://docs.hazelcast.org/docs/3.12.5/manual/html-single/index.html#fast-aggregations) to scan all cities and parallel and identify which is the closest.  In real life, the system would automatically dispatch help from the closest city.  In this lab, we will just log the fact that a crash has been detected along with the closest city.  We will also update the "status" field of the entry in the "vehicles" map so that the crash will be displayed in red on our dashboard.



When we are finished our system will look like the diagram below.



![schematic 5](media/schematic_5.png)



**A Note About Concurrent Updates**

We now have 2 jobs updating vehicles in the vehicles map.  The default behavior of the Hazelcast map sinks is to simply do a "put" on the entry.  The vehicle monitor pipeline updates the vehicle status field and the ingest pipeline updates all of the other fields.  Neither reads the entry before updating it so there is potential for the vehicle monitor pipeline to overwrite the location fields and for the ingest pipeline to overwrite the status fields. We must modify both jobs to prevent this.

There are several ways to handle this with Jet. See the [Jet Reference Manual](https://docs.hazelcast.org/docs/jet/3.2/manual/#update-entries-in-imap). In this lab the suggested approach is to use `Sinks.mapWithUpdating`.





 

