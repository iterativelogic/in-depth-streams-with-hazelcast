# Overview

In this lab we will begin to act on the data.  We will also see how Jet and IMDG together form a powerful combination.   

The engine code 'B0001' indicates that the driver airbag has deployed and is a strong indicator that a crash has occurred.  We will make a new pipeline that listens for changes from the "vehicles" map (i.e. the same map that is loaded by the ingest pipeline).  The pipeline should then filter for pings with a 'B0001' engine code.  When a crashed vehicle is found, an aggregator can be run against the "cities" map to determine the closest city.  The original vehicles map will then be updated with a "status" and "note".  We will see how to use an entry processor to safely update a vehicle entry without losing any data.  When done, the lab will look like the diagram below.



![schematic 5](media/schematic_5.png)



 __A Note About Entry Processors__

In this lab, we have two pipelines updating the same Hazelcast map.  The crash detection pipeline will be writing back to the "status" and "note" fields of the "Ping" object.  If we simply perform a put on the map, the other the crash ingestion pipeline could overwrite the other other fields, like latitude and longitude.  By the same token, we don't want the ingest pipeline to overwrite existing status and note fields.  One way to handle this would be to have the pipelines update different maps but in this case, that would lead to an unnatural segmentation of the data.  

EntryProcessors are an excellent way to handle this.  Entry processors can perform true updates (as opposed to puts which overwrite all fields) and do to the IMDG threading model they do not need transactions or other heavy synchronization mechanisms to prevent lost updates. 

Another thing EntryProcessors can do is not update the entry if there is no change.  In our example, once a vehicle has crashed its will remain in that state.  Even though new pings will be coming in with the engine code that designates a crash, there is no need to update the map entry again.  These unnecessary updates can trigger events down stream (for example, in the UI) and cause unnecessary resource consumption.

In this lab, you use an entry processor in the new pipeline and also modify the ingest pipeline to use an entry processor.



